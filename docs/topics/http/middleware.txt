==========
Middleware
==========

Middleware is a framework of hooks into Django's request/response processing.
It's a light, low-level "plugin" system for globally altering Django's input
or output.

Each middleware component is responsible for doing some specific function. For
example, Django includes a middleware component,
:class:`~django.contrib.auth.middleware.AuthenticationMiddleware`, that
associates users with requests using sessions.

This document explains how middleware works, how you activate middleware, and
how to write your own middleware. Django ships with some built-in middleware
you can use right out of the box. They're documented in the :doc:`built-in
middleware reference </ref/middleware>`.

.. versionchanged:: 1.10

    A new style of middleware was introduced. This style is used with the new
    :setting:`MIDDLEWARE` setting. You'll need to adapt old, custom middleware
    before updating to use this setting.

Writing your own middleware
===========================

A middleware factory can be written as a function that looks like this::

    def simple_middleware(get_response):
        # One-time configuration and initialization.

        def middleware(request):
            # Code to be executed for each request before
            # the view is called.

            try:
                response = get_response(request)
            except Exception as e:
                # Code to handle an exception that wasn't caught
                # further up the chain, if desired.
                ...

            # Code to be executed for each request/response after
            # the view is called.

            return response

        return middleware

Or it can be written as a class with a ``__call__()`` method, like this::

    class SimpleMiddleware(object):
        def __init__(self, get_response):
            self.get_response = get_response
            # One-time configuration and initialization.

        def __call__(self, request):
            # Code to be executed for each request before
            # the view is called.

            try:
                response = self. get_response(request)
            except Exception as e:
                # Code to handle an exception that wasn't caught
                # further up the chain, if desired.
                ...

            # Code to be executed for each request/response after
            # the view is called.

            return response

In both examples, the ``try``/``except`` isn't required if the middleware
doesn't need to handle any exceptions. If it is included, it should probably
catch something more specific than ``Exception``. The above just illustrates
how to implement the generic equivalent of ``process_exception()``.

In prose instead of examples: a middleware factory is a callable that takes a
``get_response()`` callable and returns a middleware. A middleware is a
callable that takes a request and returns a response. (Just like a view!)

The ``get_response`` callable provided by Django might be the actual view (if
this is the last listed middleware) or it might be the next middleware in the
chain. The current middleware doesn't need to know or care what exactly it is
-- just that it represents "upstream", and that it also takes a request and
returns a response.

The above is a slight simplification -- the ``get_response`` callable for the
last middleware in the chain won't be the actual view, it'll be a wrapper
method from the handler which takes care of view middleware, calling the view
with appropriate url args, and template-response middleware.

Activating middleware
=====================

To activate a middleware component, add it to the :setting:`MIDDLEWARE` list in
your Django settings.

In :setting:`MIDDLEWARE`, each middleware component is represented by a string:
the full Python path to the middleware's class or function name. For example,
here's the default value created by :djadmin:`django-admin startproject
<startproject>`::

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

A Django installation doesn't require any middleware — :setting:`MIDDLEWARE`
can be empty, if you'd like — but it's strongly suggested that you at least use
:class:`~django.middleware.common.CommonMiddleware`.

The order in :setting:`MIDDLEWARE` matters because a middleware can depend on
other middleware. For instance,
:class:`~django.contrib.auth.middleware.AuthenticationMiddleware` stores the
authenticated user in the session; therefore, it must run after
:class:`~django.contrib.sessions.middleware.SessionMiddleware`. See
:ref:`middleware-ordering` for some common hints about ordering of Django
middleware classes.

Hooks and application order
===========================

During the request phase, before calling the view, Django applies middleware
in the order it's defined in :setting:`MIDDLEWARE`, top-down. You can think of
it like an onion: each middleware class is a "layer" that wraps the view.

Besides the middlware factory pattern described earlier, two other hooks are
available:

* :meth:`process_view`
* :meth:`process_template_response` (only for template responses)

The behavior of each hook is described below.

.. _view-middleware:

``process_view()``
------------------

.. method:: process_view(request, view_func, view_args, view_kwargs)

``request`` is an :class:`~django.http.HttpRequest` object. ``view_func`` is
the Python function that Django is about to use. (It's the actual function
object, not the name of the function as a string.) ``view_args`` is a list of
positional arguments that will be passed to the view, and ``view_kwargs`` is a
dictionary of keyword arguments that will be passed to the view. Neither
``view_args`` nor ``view_kwargs`` include the first view argument
(``request``).

``process_view()`` is called just before Django calls the view.

It should return either ``None`` or an :class:`~django.http.HttpResponse`
object. If it returns ``None``, Django will continue processing this request,
executing any other ``process_view()`` middleware and, then, the appropriate
view. If it returns an :class:`~django.http.HttpResponse` object, Django won't
bother calling the appropriate view; it'll apply response middleware to that
:class:`~django.http.HttpResponse` and return the result.

.. note::

    Accessing :attr:`request.POST <django.http.HttpRequest.POST>` inside
    middleware from ``process_request`` or ``process_view`` will prevent any
    view running after the middleware from being able to :ref:`modify the
    upload handlers for the request <modifying_upload_handlers_on_the_fly>`,
    and should normally be avoided.

    The :class:`~django.middleware.csrf.CsrfViewMiddleware` class can be
    considered an exception, as it provides the
    :func:`~django.views.decorators.csrf.csrf_exempt` and
    :func:`~django.views.decorators.csrf.csrf_protect` decorators which allow
    views to explicitly control at what point the CSRF validation should occur.

.. _template-response-middleware:

``process_template_response()``
-------------------------------

.. method:: process_template_response(request, response)

``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is
the :class:`~django.template.response.TemplateResponse` object (or equivalent)
returned by a Django view or by a middleware.

``process_template_response()`` is called just after the view has finished
executing, if the response instance has a ``render()`` method, indicating that
it is a :class:`~django.template.response.TemplateResponse` or equivalent.

It must return a response object that implements a ``render`` method. It could
alter the given ``response`` by changing ``response.template_name`` and
``response.context_data``, or it could create and return a brand-new
:class:`~django.template.response.TemplateResponse` or equivalent.

You don't need to explicitly render responses -- responses will be
automatically rendered once all template response middleware has been
called.

Middleware are run in reverse order during the response phase, which
includes ``process_template_response()``.

Dealing with streaming responses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unlike :class:`~django.http.HttpResponse`,
:class:`~django.http.StreamingHttpResponse` does not have a ``content``
attribute. As a result, middleware can no longer assume that all responses
will have a ``content`` attribute. If they need access to the content, they
must test for streaming responses and adjust their behavior accordingly::

    if response.streaming:
        response.streaming_content = wrap_streaming_content(response.streaming_content)
    else:
        response.content = alter_content(response.content)

.. note::

    ``streaming_content`` should be assumed to be too large to hold in memory.
    Response middleware may wrap it in a new generator, but must not consume
    it. Wrapping is typically implemented as follows::

        def wrap_streaming_content(content):
            for chunk in content:
                yield alter_content(chunk)

.. _exception-middleware:

Exception middleware
---------------------

A middleware that does some custom exception handling might looks like this::

    class ExceptionMiddleware(object):
        def __init__(self, get_response):
            self.get_response = get_response

        def __call__(self, request):
            try:
                response = self.get_response(request)
            except Exception as e:
                # Do something with the exception and possibly reraise it
                # unless you wish to silence it.
                ...
            return response

``process_exception()`` should return either ``None`` or an
:class:`~django.http.HttpResponse` object. If it returns an
:class:`~django.http.HttpResponse` object, the template response and response
middleware will be applied, and the resulting response returned to the
browser. Otherwise, default exception handling kicks in.

Again, middleware are run in reverse order during the response phase, which
includes ``process_exception``. If an exception middleware returns a response,
the middleware classes above that middleware will not be called at all.

``__init__(get_response=None)``
-------------------------------

Middleware classes must acccept ``get_response`` argument. You can also
initialize some global state for the middleware. Keep in mind a couple of
caveats:

* Django initializes your middleware with only the ``get_response`` argument,
  so you can't define ``__init__()`` as requiring any other arguments.

* Unlike the ``__call__()`` method which get called once per request,
  ``__init__()`` is called only *once*, when the Web server starts.

.. versionchanged:: 1.10

    In older versions, ``__init__`` was not called until the Web server
    responded to its first request.

Marking middleware as unused
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's sometimes useful to determine at run-time whether a piece of middleware
should be used. In these cases, your middleware's ``__init__`` method may
raise :exc:`django.core.exceptions.MiddlewareNotUsed`. Django will then remove
that piece of middleware from the middleware process and a debug message will
be logged to the ``django.request`` logger when :setting:`DEBUG` is set to
``True``.

Guidelines
----------

* Middleware classes don't have to subclass anything.

* The middleware class can live anywhere on your Python path. All Django cares
  about is that the :setting:`MIDDLEWARE` setting includes the path to it.

* Feel free to look at :doc:`Django's available middleware </ref/middleware>`
  for examples.

* If you write a middleware component that you think would be useful to
  other people, contribute to the community! :doc:`Let us know
  </internals/contributing/index>`, and we'll consider adding it to Django.
